{
  "comments": [
    {
      "key": {
        "uuid": "5c920913_536b6406",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 110,
      "author": {
        "id": 1010333
      },
      "writtenOn": "2014-03-03T20:02:46Z",
      "side": 1,
      "message": "looking at this again, I think it would be simpler to do this check in PatchCache::removeDeferred(), so that mGarbage and  patchesToRemove both never have duplicates.",
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccb593b_ab3ee936",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 110,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-05T14:22:58Z",
      "side": 1,
      "message": "This was seen as the \"minimal change\" to allow for contribution and review. \n\nThough the patch has my name, this filtering part was actually added by another developer here. I\u0027m however very interested in why there are duplicates to begin with and to learn more of the original design ideas. \n\nI will add some of my comments/questions in the review, but feel free to email me if that is more convenient for discussions. Those questions are intended for the reviewers, rather than to the submitter. :)",
      "parentUuid": "5c920913_536b6406",
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dccb593b_ceeca337",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 111,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-05T14:22:58Z",
      "side": 1,
      "message": "As far as I\u0027ve seen these lists are fairly short. Still I would hesitate to add more list iteration. \n\nIt would be possible to remove the iteration for duplicates if the patch had a flag (e.g. mDead) to signal if it was \"already garbage\" or not. I assume this is an unwanted exposure of the cache. But in cache there are other containers, such as patch_pair_t, that could possibly have the flag if wanted.",
      "range": {
        "startLine": 111,
        "startChar": 27,
        "endLine": 111,
        "endChar": 42
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc2511e_70430e84",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 123,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-05T14:22:58Z",
      "side": 1,
      "message": "It\u0027s sad to see the LruCache iterated when there is an index in it. Problem is that each \"patch\" may be cached as several sizes, so patch can not be the key. \n\nThis loop is responsible to identify each of those references (in mCache) and add them to patchesToRemove. \n\nIs this the correct interpretation?",
      "range": {
        "startLine": 123,
        "startChar": 13,
        "endLine": 123,
        "endChar": 17
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dcf7d997_f42509be",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 123,
      "author": {
        "id": 1010333
      },
      "writtenOn": "2014-03-10T23:30:52Z",
      "side": 1,
      "message": "This loop identifies each Description/Patch pair that comes from the about-to-be-deleted Res_png_9_patch, and adds them to patchesToRemove.\n\nRes_png_9_patch as you say, can\u0027t be the key, since multiple instances of those will come with multiple sizes.",
      "parentUuid": "1cc2511e_70430e84",
      "range": {
        "startLine": 123,
        "startChar": 13,
        "endLine": 123,
        "endChar": 17
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc2511e_30b586f7",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 133,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-05T14:22:58Z",
      "side": 1,
      "message": "I find this function elegant and quick in current implementation (as long as there is room in the Vector and the mLock is available).\n\nWas the suggestion to rebrand and modify hasItem() to iterate mGarbage and call it from here? Or would you suggest another collection type for mGarbage?",
      "range": {
        "startLine": 133,
        "startChar": 13,
        "endLine": 133,
        "endChar": 17
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dcf7d997_20df50a8",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 133,
      "author": {
        "id": 1010333
      },
      "writtenOn": "2014-03-10T23:30:52Z",
      "side": 1,
      "message": "I retract my earlier comment - duplicates aren\u0027t from this function getting called multiple times, but rather from multiple entries of the same Res_png_9_patch pointed to by Description/Patch pairs in the hashmap. This is fine as is.",
      "parentUuid": "1cc2511e_30b586f7",
      "range": {
        "startLine": 133,
        "startChar": 13,
        "endLine": 133,
        "endChar": 17
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dce519f4_1bda9bb7",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 133,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-11T15:28:41Z",
      "side": 1,
      "message": "Your comment had merit regardless of that.\n\nThis patch was prepared without knowing of\nhttps://android-review.googlesource.com/#/c/74220\n\nMy interpretation of the explanation to that patch is that mGarbage did have duplicate entries from multiple calls here. The interesting part was that this was not intended as duplicates, given that they were actually different objects that just happened to get the same address.\n\nIf that patch correctly prevents duplicates in mGarbage the hasItem() filter may not be needed. Do you happen to have any test cases that can be used to verify this? Or should an assert be added to secure the design requirement?",
      "parentUuid": "dcf7d997_20df50a8",
      "range": {
        "startLine": 133,
        "startChar": 13,
        "endLine": 133,
        "endChar": 17
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dcf7d997_a607ce74",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 133,
      "author": {
        "id": 1010333
      },
      "writtenOn": "2014-03-11T20:30:13Z",
      "side": 1,
      "message": "Unfortunately I don\u0027t have any tests for this path. I\u0027d prefer an assert LOG_ALWAYS_FATAL_IF() in here to verify there aren\u0027t any duplicates, since the only \"legitimate\" duplicates should no longer exist because of the other patch, as you say.",
      "parentUuid": "dce519f4_1bda9bb7",
      "range": {
        "startLine": 133,
        "startChar": 13,
        "endLine": 133,
        "endChar": 17
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc2511e_cdcd89fe",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 136,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-05T14:22:58Z",
      "side": 1,
      "message": "Is it entirely sure that all \"removeGarbage\" are called before \"clearGarbage\" or is there a risk that one of the (several) references to a patch is still \"out there\" - possibly coming in later on and thus not detected as duplicate/already freed? (In the best of worlds remove() would then not find any match, but...)",
      "range": {
        "startLine": 136,
        "startChar": 17,
        "endLine": 136,
        "endChar": 29
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9c2ba1c2_5e0a31b7",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 136,
      "author": {
        "id": 1010333
      },
      "writtenOn": "2014-03-10T23:30:52Z",
      "side": 1,
      "message": "sorry, I don\u0027t follow - removeGarbage?\n\nThe design is that mGarbage contains patches that *only* the PatchCache has a reference to, and which are referenced no where else (since both Java and the DisplayLists have given up all references).",
      "parentUuid": "1cc2511e_cdcd89fe",
      "range": {
        "startLine": 136,
        "startChar": 17,
        "endLine": 136,
        "endChar": 29
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3c1ab5b4_8c1beb85",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 136,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-11T15:28:41Z",
      "side": 1,
      "message": "My bad - replace \"removeGarbage\" with \"removeDeferred\". \n\nI now understand that the design does rule out any reference \"still out there\". Any \"risk\" of double free based on that scenario would thus be a bug that would be beneficial to find rather than to protect from.",
      "parentUuid": "9c2ba1c2_5e0a31b7",
      "range": {
        "startLine": 136,
        "startChar": 17,
        "endLine": 136,
        "endChar": 29
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc2511e_f0a37e29",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 140,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-05T14:22:58Z",
      "side": 1,
      "message": "mLock seems to protect mGarbage only. Is mCache accessed only from single thread?\n\nMy assumption is that the use of patchesToRemove instead of doing the changes (e.g. mCache and mFreeBlocks) immediately in this loop is to keep the mLock scope short. \n\nIs the hasItem search ok to have in that scope? (Regardless if here or in removeDeferred.)",
      "range": {
        "startLine": 140,
        "startChar": 26,
        "endLine": 140,
        "endChar": 27
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dcf7d997_4057fc46",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 140,
      "author": {
        "id": 1010333
      },
      "writtenOn": "2014-03-10T23:30:52Z",
      "side": 1,
      "message": "mCache is only accessed from the rendering thread, mGarbage is the only thing accessed from multiple threads.",
      "parentUuid": "1cc2511e_f0a37e29",
      "range": {
        "startLine": 140,
        "startChar": 26,
        "endLine": 140,
        "endChar": 27
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3c1ab5b4_8ce92b26",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 144,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-11T15:28:41Z",
      "side": 1,
      "message": "Chris Craik said on review cover note something I summarize like this:\n\n\u003e I\u0027m not seeing the point of the hasItem() function, one\n\u003e Res_png_9_patch is used on the background of several \n\u003e Description/Patch pair, and we\u0027ll still want to delete \n\u003e all of those in mCache.\n\n\nMaybe I\u0027m misunderstanding the question, but let me explain my view.\n\nfor (size_t i \u003d 0; i \u003c count; i++) {\n  if (!hasItem(patchesToRemove, mGarbage[i]))\n    remove(patchesToRemove, mGarbage[i]);\n}\n\nThe iteration is over every Res_png_9_patch* in mGarbage. remove() will make sure that EVERY matching Description/Patch pair in mCache is listed in patchesToRemove (as a patch_pair_t). \n\nWhat hasItem() does is to look if there are ANY patch_pair_t already in patchesToRemove that is matching the Res_png_9_patch in question. (The PatchDescription has a reference to Res_png_9_patch...)\n\nThis way EVERY matching pair is indeed destroyed once, if ANY of them is. That should cover \"want to delete all of those\".\n\nThe question \"is there a point filtering with hasItem?\"  may have another answer. The filter was added due to double free of Patch (as where before my patch there were no free at all so the problem was fairly undetected). \n\nPatchCache::get() seems to cause a one-to-one relation for Description/Patch. So if that assumption holds the filter is equivalent to filter for duplicate entries in mGarbage. \n\nIf that other patch correctly prevents duplicates in mGarbage the hasItem() filter may not be needed and I would happily remove it. Do you happen to have any test cases that can be used to verify this?",
      "range": {
        "startLine": 144,
        "startChar": 17,
        "endLine": 144,
        "endChar": 24
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3c52b523_77b8af59",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 149,
      "author": {
        "id": 1010333
      },
      "writtenOn": "2014-03-03T20:02:46Z",
      "side": 1,
      "message": "This delete (which is new because of the rebase) is the reason I suggested the above - protecting against duplicates in patchesToRemove is good, but avoiding duplicates in the first place avoids a double delete here.\n\n(This could just be put in the if statement, but I think it\u0027s cleaner to just always avoid duplicates).",
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc2511e_d090c283",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 149,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-05T14:22:58Z",
      "side": 1,
      "message": "Another way could be to move delete[] into the remove-function. If it\u0027s called \"remove\" at least it should remove something. :)",
      "parentUuid": "3c52b523_77b8af59",
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dc10b997_06e87cd2",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 149,
      "author": {
        "id": 1010333
      },
      "writtenOn": "2014-03-10T23:30:52Z",
      "side": 1,
      "message": "Let\u0027s just leave it as is for now - this way at least the object isn\u0027t destroyed until it\u0027s no longer held.",
      "parentUuid": "1cc2511e_d090c283",
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcce5d4a_ef2e3dbc",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 154,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-05T14:22:58Z",
      "side": 1,
      "message": "For future review: Is it the \"patchesToRemove\" or mFreeBlocks that should be sorted?",
      "range": {
        "startLine": 154,
        "startChar": 27,
        "endLine": 154,
        "endChar": 42
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3cf1d5a2_6321602c",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 154,
      "author": {
        "id": 1010333
      },
      "writtenOn": "2014-03-10T23:30:52Z",
      "side": 1,
      "message": "the TODO here sounds like it may be referring to mFreeBlocks, but actually sorting both would simplify the process of merging blocks.\n\nEither way, merging blocks isn\u0027t very high priority since we get very good reuse due to many patches using the same block size.",
      "parentUuid": "fcce5d4a_ef2e3dbc",
      "range": {
        "startLine": 154,
        "startChar": 27,
        "endLine": 154,
        "endChar": 42
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dce519f4_fb9fafce",
        "filename": "libs/hwui/PatchCache.cpp",
        "patchSetId": 4
      },
      "lineNbr": 154,
      "author": {
        "id": 1042369
      },
      "writtenOn": "2014-03-11T15:28:41Z",
      "side": 1,
      "message": "I agree, still I think it may be a little more efficient to just modify the size of an adjacent block rather than to create and destroy one BufferBlock every time.\n\nBut that\u0027s outside this review, just a thought I had when considering searching patchesToRemove for duplicates.",
      "parentUuid": "3cf1d5a2_6321602c",
      "range": {
        "startLine": 154,
        "startChar": 27,
        "endLine": 154,
        "endChar": 42
      },
      "revId": "cb119696f2027269273e11b57a05d6c237a09b57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}