{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f2d5c09e_8da8c594",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2021-06-01T17:15:20Z",
      "side": 1,
      "message": "Thank you for this patch. We actually already removed this code internally.\n\nThe original CL, https://cs.android.com/android/_/android/platform/frameworks/base/+/48f110ec7bcbc28f9e2f0625f1e6f936827d26d6, was reverted.\n\nThe correct solution is aosp/1459888.\n\nIf you would like, you can update this CL to remove the batched consumption completely (and specify DO NOT MERGE).\n\nHere\u0027s the diff for the revert:\n\nFrom 3d34eeb8d0db6322c8871f22cb401c26fa2c1c27 Mon Sep 17 00:00:00 2001\nFrom: Siarhei Vishniakou \u003csvv@google.com\u003e\nDate: Mon, 19 Oct 2020 13:38:31 -0500\nSubject: [PATCH] Remove batched consumption from onStop\n\nThis patch reverts the earlier patch, ag/11959351, because the correct\nsolution is aosp/1459888.\n\nWhen batched input is available, the Choreographer::CALLBACK_INPUT is\nscheduled by ViewRootImpl. The callback always runs, even if onStop has\nbeen called. So the earlier patch was invalid.\n\nIn practice, what happened was that the batched input was not getting\nconsumed after FOCUS event was received in the receiver. This was fixed\nin aosp/1459888.\n\nThe consumption mechanism is complex, so I added a doc explaining how it\nworks, for future readers.\n\nThe newly added test, IncompleteMotionTest, ensures that this regression\ndoes not happen again.\n\nTest: atest IncompleteMotionTest\nBug: 160561987\nChange-Id: Ic0a453ebbce1f847de8e9cb87bdffdaf72c12637\n---\n\ndiff --git a/core/java/android/view/ViewRootImpl.java b/core/java/android/view/ViewRootImpl.java\nindex 9bc0770..f1005e9 100644\n--- a/core/java/android/view/ViewRootImpl.java\n+++ b/core/java/android/view/ViewRootImpl.java\n@@ -1758,7 +1758,6 @@\n                 destroySurface();\n             }\n         }\n-        scheduleConsumeBatchedInputImmediately();\n     }\n \n \n@@ -8314,11 +8313,8 @@\n \n         @Override\n         public void onBatchedInputEventPending(int source) {\n-            // mStopped: There will be no more choreographer callbacks if we are stopped,\n-            // so we must consume all input immediately to prevent ANR\n             final boolean unbuffered \u003d mUnbufferedInputDispatch\n-                    || (source \u0026 mUnbufferedInputSource) !\u003d SOURCE_CLASS_NONE\n-                    || mStopped;\n+                    || (source \u0026 mUnbufferedInputSource) !\u003d SOURCE_CLASS_NONE;\n             if (unbuffered) {\n                 if (mConsumeBatchedInputScheduled) {\n                     unscheduleConsumeBatchedInput();\ndiff --git a/core/jni/android_view_InputEventReceiver.md b/core/jni/android_view_InputEventReceiver.md\nnew file mode 100644\nindex 0000000..7df3461\n--- /dev/null\n+++ b/core/jni/android_view_InputEventReceiver.md\n@@ -0,0 +1,49 @@\n+# Batched consumption #\n+\n+Most apps draw once per vsync. Therefore, apps can only respond to 1 input event per frame. If multiple input events come in during the period of 1 vsync, it would be wasteful to deliver them all at once to the app. For this reason, input events are batched to only deliver 1 event per frame to the app.\n+\n+The batching process works in the following manner:\n+\n+1. `InputDispatcher` sends an event to the app\n+2. The app\u0027s `Looper` is notified about the available event.\n+3. The `handleEvent` callback is executed. Events are read from fd.\n+4. If a batched input event is available, `InputConsumer::hasPendingBatch` returns true. No event is sent to the app at this point.\n+5. The app is notified that a batched event is available for consumption, and schedules a runnable via the `Choreographer` to consume it a short time before the next frame\n+6. When the scheduled runnable is executed, it doesn\u0027t just consume the batched input. It proactively tries to consume everything that has come in to the socket.\n+7. The batched event is sent to the app, along with any of the other events that have come in.\n+\n+Let\u0027s discuss the specifics of some of these steps.\n+\n+## 1. Consuming events in `handleEvent` callback ##\n+\n+The app is notified about the available event via the `Looper` callback `handleEvent`. When the app\u0027s input socket becomes readable (e.g., it has unread events), the looper will execute `handleEvent`. At this point, the app is expected to read in the events that have come in to the socket. The function `handleEvent` will continue to trigger as long as there are unread events in the socket. Thus, the app could choose to read events 1 at a time, or all at once. If there are no more events in the app\u0027s socket, handleEvent will no longer execute.\n+\n+Even though it is perfectly valid for the app to read events 1 at a time, it is more efficient to read them all at once. Therefore, whenever the events are available, the app will try to completely drain the socket.\n+\n+To consume the events inside `handleEvent`, the app calls `InputConsumer::consume(.., consumeBatches\u003dfalse, frameTime\u003d-1, ..)`. That is, when `handleEvent` runs, there is no information about the upcoming frameTime, and we dont want to consume the batches because there may be other events that come in before the \u0027consume batched input\u0027 runnable runs.\n+\n+If a batched event comes in at this point (typically, any MOVE event that has source \u003d TOUCHSCREEN), the `consume` function above would actually return a `NULL` event with status `WOULD_BLOCK`. When this happens, the caller (`NativeInputEventReceiver`) is responsible for checking whether `InputConsumer::hasPendingBatch` is set to true. If so, the caller is responsible for scheduling a runnable to consume these batched events.\n+\n+## 2. Consuming batched events ##\n+\n+In the previous section, we learned that the app can read events inside the `handleEvent` callback. The other time when the app reads events is when the \u0027consume batched input\u0027 runnable is executed. This runnable is scheduled via the Choreographer by requesting a `CALLBACK_INPUT` event.\n+\n+Before the batched events are consumed, the socket is drained once again. This is an optimization.\n+\n+To consume the events inside \u0027consume batched input\u0027 runnable, the app calls `InputConsumer::consume(.., consumeBatches\u003dtrue, frameTime\u003d\u003cvalid frame time\u003e, ..)`. At this point, the `consume` function will return all batched events up to the `frameTime` point. There may be batched events remaining.\n+\n+## 3. Key points ##\n+\n+Some of the behaviours above should be highlighted, because they may be unexpected.\n+\n+1. Even if events have been read by `InputConsumer`, `consume` will return `NULL` event with status `WOULD_BLOCK` if those events caused a new batch to be started.\n+\n+2. Events are read from the fd outside of the regular `handleEvent` case, during batched consumption.\n+\n+3. The function `handleEvent` will always execute as long as there are unread events in the fd\n+\n+4. The `consume` function is called in 1 of 2 possible ways:\n+   - `consumeBatches\u003dfalse, frameTime\u003d-1`\n+   - `consumeBatches\u003dtrue, frameTime\u003d\u003cvalid time\u003e`\n+\n+   I.e., it is never called with `consumeBatches\u003dtrue, frameTime\u003d-1`.\ndiff --git a/tests/Input/AndroidManifest.xml b/tests/Input/AndroidManifest.xml\nindex 4195df7..20f564e 100644\n--- a/tests/Input/AndroidManifest.xml\n+++ b/tests/Input/AndroidManifest.xml\n@@ -27,7 +27,6 @@\n              android:process\u003d\":externalProcess\"\u003e\n         \u003c/activity\u003e\n \n-\n     \u003c/application\u003e\n     \u003cinstrumentation android:name\u003d\"androidx.test.runner.AndroidJUnitRunner\"\n                      android:targetPackage\u003d\"com.android.test.input\"",
      "revId": "cb3219927335df092ac907659be18285c1653649",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}