{
  "comments": [
    {
      "key": {
        "uuid": "83cc83a7_e6b1a84a",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2019-04-23T09:34:29Z",
      "side": 1,
      "message": "Consider putting the ternary operator clauses in () to improve readability. Technically this almost certainly isn\u0027t necessary because the only operators that have lower precedence than ? are assignments like +\u003d or \u003d, but it doesn\u0027t hurt.",
      "range": {
        "startLine": 126,
        "startChar": 25,
        "endLine": 126,
        "endChar": 75
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1c5d499_e2720121",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1337176
      },
      "writtenOn": "2019-04-24T07:27:49Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "83cc83a7_e6b1a84a",
      "range": {
        "startLine": 126,
        "startChar": 25,
        "endLine": 126,
        "endChar": 75
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1357a035_dfba82fc",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 170,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2019-04-23T09:34:29Z",
      "side": 1,
      "message": "This is so unexpected that it might be worth logging an error.",
      "range": {
        "startLine": 170,
        "startChar": 12,
        "endLine": 170,
        "endChar": 24
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c4c1ce79_3007d8eb",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 170,
      "author": {
        "id": 1337176
      },
      "writtenOn": "2019-04-24T07:27:49Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1357a035_dfba82fc",
      "range": {
        "startLine": 170,
        "startChar": 12,
        "endLine": 170,
        "endChar": 24
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6134ff04_9b40a44f",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 170,
      "author": {
        "id": 1337176
      },
      "writtenOn": "2019-04-24T07:27:49Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1357a035_dfba82fc",
      "range": {
        "startLine": 170,
        "startChar": 12,
        "endLine": 170,
        "endChar": 24
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "83f48063_b50f4239",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 173,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2019-04-23T09:34:29Z",
      "side": 1,
      "message": "Ouch. :-(\n\nWhat this means is that if the default network changes while the addresses are being sorted then the results will be incorrect.\n\nAnd it occurs to me that there\u0027s an even bigger problem than this one, too: the DnsResolver#query() method that does two DNS queries (i.e., the one that calls this code) needs to get the right netId before doing the queries, because otherwise if the default network changes while it is running, it could end up doing the A query on one network and the AAAA on another network.\n\nFor this CL, we could just refuse to allow users to pass a null netId to that method until we fix the problem.\n\nAs for fixing the problem... I think one way to do it would be: if the passed-in network is null, set it explicitly in the code to the app\u0027s current default network for DNS. The following might work:\n1. Get a pointer to ConnectivityService via ServiceManager.getService (see TrafficStats#getStatsService for an example of how to do this) and call getActiveNetwork on it.\n2. Pass that network to getNetworkForResolv() in libnetd_client.\n\nEven that might not work in the case of a split tunnel VPN. The rules for this are very complex; take a look at NetworkController::getNetworkForDnsLocked. Given all the complexity and the risk of the two implementations getting out of sync, it might be simpler to just add an IPC to DnsProxyListener (or even to FwmarkServer) to return the network for DNS resolution.\n\nHowever, it\u0027s already the case that split-tunnel VPNs don\u0027t behave properly in some situations. So perhaps this is fine.\n\nYet another option would be just to delegate all this to netd entirely, and have the IPv4+IPv6 query() method just call the DnsProxyListener getaddrinfo() method. This will have other side effects such as send the two DNS queries in series instead of in parallel, and processing the domain search list. On the other hand, maybe perfect consistency with getaddrinfo is actually what we want here.\n\nThoughts?",
      "range": {
        "startLine": 173,
        "startChar": 12,
        "endLine": 173,
        "endChar": 32
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70275590_8b85b870",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 173,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2019-04-23T09:51:32Z",
      "side": 1,
      "message": "When I say \"call the DnsProxyListener getaddrinfo() method\", I think I mean:\n\n- Factor out to some common method the code that sends the query to the proxy and the code that parses the response (right now I think this is in android_getaddrinfo_proxy), and call that via JNI, or:\n- Write another implementation of that code in Java.\n\nIn any case we would poll() on the fd via the FD event listener like we do now.",
      "parentUuid": "83f48063_b50f4239",
      "range": {
        "startLine": 173,
        "startChar": 12,
        "endLine": 173,
        "endChar": 32
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "77888343_6f77040b",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 173,
      "author": {
        "id": 1337176
      },
      "writtenOn": "2019-04-24T07:27:49Z",
      "side": 1,
      "message": "Not sure I understand it well,\nIf the network is null, we could choose the default one to perform both of v4/v6 query.\nDnsProxyListener will use the same netId to get networkContext between v4 and v6 query.\nIf the network is changed during query, I saw the difference as below.\nAnything I missed?\n\ngetaddrinfo:\n       mark(networkcontext) is set in DnsProxyListener    (once)\n    querying:\n       setsockopt is called before querying in res_send.cpp(send_dg/send_vc, or tls)\n Suddenly, network changed\n    sorting:\n       setsockopt is called in getaddrinfo.cpp (_find_src_addr)\n---------------------------------------------------------------------------------\nDnsResolver#query:\n       mark(networkcontext) is set in DnsProxyListener    (twice, but must be the same networkcontext)\n    querying:\n       setsockopt is called before querying in res_send.cpp(send_dg/send_vc, or tls)       \n Suddenly, network changed\n    sorting:\n       setsockopt is called here (findSrcAddress)     (SelectNetwork checking in FwServer will fail, so no setsockopt will not be called, we will get no srcAddress)",
      "parentUuid": "70275590_8b85b870",
      "range": {
        "startLine": 173,
        "startChar": 12,
        "endLine": 173,
        "endChar": 32
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1097e8df_db19f201",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 174,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2019-04-23T09:51:32Z",
      "side": 1,
      "message": "Note that this will not be instant - it will involve opening a UNIX socket to netd, sending the fd over it so that netd can mark it, and getting the fd back. This operation is single-threaded inside netd, and while it\u0027s pretty fast (benchmarks say a few thousand of these per second IIRC) the time might add up, because we call this many times (one per destination IP address). FOr non-cached queries it probably doesn\u0027t matter, but it might slow down cached queries.",
      "range": {
        "startLine": 174,
        "startChar": 15,
        "endLine": 174,
        "endChar": 22
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dde25753_f49ec603",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 174,
      "author": {
        "id": 1337176
      },
      "writtenOn": "2019-04-24T07:27:49Z",
      "side": 1,
      "message": "So we might want to have a way to bypass the checking, right?\nAdd a method for finding srcAddress in netdclient could do that. But I wonder if it is allowed.",
      "parentUuid": "1097e8df_db19f201",
      "range": {
        "startLine": 174,
        "startChar": 15,
        "endLine": 174,
        "endChar": 22
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bced8b16_986a1d14",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 225,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2019-04-23T09:34:29Z",
      "side": 1,
      "message": "Can this actually happen? The documentation for Inet6Address states \"Java will never return an IPv4-mapped address. These classes can take an IPv4-mapped address as input, both in byte array and text representation. However, it will be converted into an IPv4 address.\"\n\nWhere do these addresses come from? The source addresses come from Os.getsockname(), right? Looking at doGetSockName and sockaddrToInetAddress, it looks like those never return IPv6-mapped addresses either. And looks like destinations come from InetAddress.getByAddress in DnsAddressAnswer#getAddresses. And InetAddress#getByAddress calls convertFromIPv4MappedAddress, which does the same.\n\nNot sure what to do about this. Either we can leave this code in here, but add a comment that says it\u0027s not necessary due to the analysis above... or we can delete this code and add a comment to findLabel explaining that we don\u0027t need it.",
      "range": {
        "startLine": 225,
        "startChar": 27,
        "endLine": 225,
        "endChar": 48
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "98fb33e9_adf3e967",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 225,
      "author": {
        "id": 1337176
      },
      "writtenOn": "2019-04-24T07:27:49Z",
      "side": 1,
      "message": "Thanks, I don\u0027t notice that.\nDone",
      "parentUuid": "bced8b16_986a1d14",
      "range": {
        "startLine": 225,
        "startChar": 27,
        "endLine": 225,
        "endChar": 48
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b634151_8e599058",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 349,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2019-04-23T09:34:29Z",
      "side": 1,
      "message": "Can you use numberOfLeadingZeros here? \"x \u003d srcByte[i] ^ dstByte[i]\" will ensure that any identical bits get forced to zero. So the first non-zero bit in x is the first bit where srcByte[i] and dstByte[i] differ. Maybe just:\n\n    int x \u003d srcByte[i] ^ dstByte[i];\n    return i * CHAR_BIT + numberOfLeadingZeros(x);\n\nAlso, due to the fact that Java bytes are signed, do you need to do something like:\n\n    int x \u003d BitUtils.uint8(srcByte[i]) ^ BitUtils.uint8(dstByte[i]);\n\nNot sure how to unit test for this.",
      "range": {
        "startLine": 344,
        "startChar": 0,
        "endLine": 349,
        "endChar": 13
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "594a193e_8f07f2c1",
        "filename": "core/java/android/net/util/DnsUtils.java",
        "patchSetId": 1
      },
      "lineNbr": 349,
      "author": {
        "id": 1337176
      },
      "writtenOn": "2019-04-24T07:27:49Z",
      "side": 1,
      "message": "Done.",
      "parentUuid": "8b634151_8e599058",
      "range": {
        "startLine": 344,
        "startChar": 0,
        "endLine": 349,
        "endChar": 13
      },
      "revId": "f4d87b13f5b99930c84586f9b063f15a0f21a56b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}