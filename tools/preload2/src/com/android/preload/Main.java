/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.preload;

import com.android.ddmlib.Client;
import com.android.ddmlib.ClientData;
import com.android.ddmlib.IDevice;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.io.File;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

import javax.swing.AbstractAction;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.JToolBar;
import javax.swing.SwingUtilities;
import javax.swing.table.AbstractTableModel;

/**
 * TODO: Insert description here. (generated by agampe)
 */
public class Main extends JFrame {

    // Enable tracing mode. This is a work-in-progress to derive compiled-methods data, so keep it
    // off for now.
    public final static boolean ENABLE_TRACING = false;

    private IDevice device;

    private JList<Client> clientList;
    private JTable dataTable;
    private DumpTableModel dataTableModel;

    // Shared file chooser, means the directory is retained.
    private JFileChooser jfc;

    // Top-level frame, used as the parent of wait dialog. Set to Main.this.
    private static JFrame top;

    public final static String CLASS_PRELOAD_BLACKLIST = "android.app.AlarmManager$" + "|"
            + "android.app.SearchManager$" + "|" + "android.os.FileObserver$" + "|"
            + "com.android.server.PackageManagerService\\$AppDirObserver$" + "|" +


            // Threads
            "android.os.AsyncTask$" + "|" + "android.pim.ContactsAsyncHelper$" + "|"
            + "android.webkit.WebViewClassic\\$1$" + "|" + "java.lang.ProcessManager$" + "|"
            + "(.*\\$NoPreloadHolder$)";

    /**
     * @param args
     */
    public static void main(String[] args) {
        Main m = new Main();
        top = m;

        m.startUp();
    }

    public Main() {
        super("Preloaded-classes computation");

        getContentPane().add(new JScrollPane(clientList = new JList<Client>()), BorderLayout.WEST);
        clientList.setCellRenderer(new ClientListCellRenderer());
        // clientList.addListSelectionListener(listener);

        dataTableModel = new DumpTableModel();
        dataTable = new JTable(dataTableModel);
        getContentPane().add(new JScrollPane(dataTable), BorderLayout.CENTER);

        JToolBar toolbar = new JToolBar(JToolBar.HORIZONTAL);
        toolbar.add(new ReloadListAction());
        toolbar.add(new ClearAction());
        toolbar.add(new RunMonkeyAction());
        toolbar.add(new ScanPackageAction());
        toolbar.add(new ScanAllPackagesAction());
        toolbar.add(new ComputeThresholdAction("Compute preloaded-classes", 2,
                CLASS_PRELOAD_BLACKLIST));
        toolbar.add(new ComputeThresholdAction("Compute compiled-classes", 1, null));
        toolbar.add(new ComputeThresholdXAction("Compute(X)", CLASS_PRELOAD_BLACKLIST));
        toolbar.add(new ShowDataAction());
        toolbar.add(new ImportAction());
        toolbar.add(new ExportAction());
        getContentPane().add(toolbar, BorderLayout.PAGE_START);

        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setBounds(100, 100, 800, 600);
        setVisible(true);
    }

    private void addData(String packageName, Map<String, String> dumpData) {
        System.out.println("Adding data for " + packageName);
        DumpData data = new DumpData(packageName, dumpData, new Date());
        dataTableModel.addData(data);
    }

    static class DeviceWrapper {
        IDevice device;

        public DeviceWrapper(IDevice d) {
            device = d;
        }

        @Override
        public String toString() {
            return device.getName() + " (#" + device.getSerialNumber() + ")";
        }
    }

    private void startUp() {
        showWaitDialog();
        initDevice();
        loadClients();
        hideWaitDialog();
    }

    private void initDevice() {
        DeviceUtils.init();

        IDevice devices[] = DeviceUtils.findDevices();
        if (devices == null || devices.length == 0) {
            throw new RuntimeException("Could not find any devices...");
        }

        hideWaitDialog();

        DeviceWrapper deviceWrappers[] = new DeviceWrapper[devices.length];
        for (int i = 0; i < devices.length; i++) {
            deviceWrappers[i] = new DeviceWrapper(devices[i]);
        }

        Object ret = JOptionPane.showInputDialog(Main.this,
                "Choose a device",
                "Choose device",
                JOptionPane.QUESTION_MESSAGE,
                null,
                deviceWrappers,
                deviceWrappers[0]);
        if (ret != null) {
            device = ((DeviceWrapper) ret).device;
        } else {
            System.exit(0);
        }

        int prepare = JOptionPane.showConfirmDialog(Main.this, "Prepare device?",
                "Do you want to prepare the device? This is highly recommended.",
                JOptionPane.YES_NO_OPTION);
        if (prepare == JOptionPane.YES_OPTION) {
            String buildType = DeviceUtils.getBuildType(device);
            if (buildType == null || (!buildType.equals("userdebug") && !buildType.equals("eng"))) {
                JOptionPane.showMessageDialog(Main.this,
                        "Need a userdebug or eng build! (Found " + buildType + ")");
                return;
            }
            if (DeviceUtils.hasPrebuiltBootImage(device)) {
                JOptionPane.showMessageDialog(Main.this,
                        "Cannot prepare a device with pre-optimized boot image!");
                return;
            }

            if (ENABLE_TRACING) {
                DeviceUtils.enableTracing(device);
            }

            JOptionPane.showMessageDialog(Main.this,
                    "The device will reboot. This will potentially take a long time. Please be patient.");
            if (!DeviceUtils.removePreloaded(device, 15 * 60) /* 15m timeout */) {
                JOptionPane.showMessageDialog(Main.this,
                        "Removing preloaded-classes failed unexpectedly!");
            }
        }
    }

    private static class ClientComparator implements Comparator<Client> {

        /*
         * (non-Javadoc)
         *
         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
         */
        @Override
        public int compare(Client o1, Client o2) {
            String s1 = o1.getClientData().getClientDescription();
            String s2 = o2.getClientData().getClientDescription();

            if (s1 == null || s2 == null) {
                // Not good, didn't get all data?
                return (s1 == null) ? -1 : 1;
            }

            return s1.compareTo(s2);
        }

    }

    private void loadClients() {
        Client[] clients = ClientUtils.findAllClients(device);
        if (clients != null) {
            Arrays.sort(clients, new ClientComparator());
        }
        clientList.setListData(clients);
    }

    private class ClientListCellRenderer extends DefaultListCellRenderer {

        /*
         * (non-Javadoc)
         *
         * @see javax.swing.DefaultListCellRenderer#getListCellRendererComponent(javax.swing.JList,
         * java.lang.Object, int, boolean, boolean)
         */
        @Override
        public Component getListCellRendererComponent(JList<?> list, Object value, int index,
                boolean isSelected, boolean cellHasFocus) {
            ClientData cd = ((Client) value).getClientData();
            String s = cd.getClientDescription() + " (pid " + cd.getPid() + ")";
            return super.getListCellRendererComponent(list, s, index, isSelected, cellHasFocus);
        }
    }

    private static JDialog currentWaitDialog = null;

    public static void showWaitDialog() {
        if (currentWaitDialog == null) {
            currentWaitDialog = new JDialog(top, "Please wait...", true);
            currentWaitDialog.getContentPane().add(new JLabel("Please be patient."),
                    BorderLayout.CENTER);
            JProgressBar progress = new JProgressBar(JProgressBar.HORIZONTAL);
            progress.setIndeterminate(true);
            currentWaitDialog.getContentPane().add(progress, BorderLayout.SOUTH);
            currentWaitDialog.setSize(200, 100);
            currentWaitDialog.setLocationRelativeTo(null);
            SwingUtilities.invokeLater(new Runnable() {
                @Override
                public void run() {
                    if (currentWaitDialog != null) {
                        currentWaitDialog.setVisible(true); // This is blocking.
                    }
                }
            });
        }
    }

    public static void updateWaitDialog(String s) {
        if (currentWaitDialog != null) {
            ((JLabel) currentWaitDialog.getContentPane().getComponent(0)).setText(s);
            Dimension prefSize = currentWaitDialog.getPreferredSize();
            Dimension curSize = currentWaitDialog.getSize();
            if (prefSize.width > curSize.width || prefSize.height > curSize.height) {
                currentWaitDialog.setSize(Math.max(prefSize.width, curSize.width),
                        Math.max(prefSize.height, curSize.height));
                currentWaitDialog.invalidate();
            }
        }
    }

    public static void hideWaitDialog() {
        if (currentWaitDialog != null) {
            currentWaitDialog.setVisible(false);
            currentWaitDialog = null;
        }
    }

    private class ReloadListAction extends AbstractAction implements Runnable {
        public ReloadListAction() {
            super("Reload");
        }

        /*
         * (non-Javadoc)
         *
         * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
         */
        @Override
        public void actionPerformed(ActionEvent e) {
            new Thread(this).start();
        }

        /*
         * (non-Javadoc)
         *
         * @see java.lang.Runnable#run()
         */
        @Override
        public void run() {
            loadClients();
        }
    }

    private class ClearAction extends AbstractAction {
        public ClearAction() {
            super("Clear");
        }

        /*
         * (non-Javadoc)
         *
         * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
         */
        @Override
        public void actionPerformed(ActionEvent e) {
            dataTableModel.clear();
        }
    }

    private class ScanPackageAction extends AbstractAction implements Runnable {
        public ScanPackageAction() {
            super("Scan package");
        }

        /*
         * (non-Javadoc)
         *
         * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
         */
        @Override
        public void actionPerformed(ActionEvent e) {
            new Thread(this).start();
        }

        /*
         * (non-Javadoc)
         *
         * @see java.lang.Runnable#run()
         */
        @Override
        public void run() {
            showWaitDialog();

            try {
                Client client = clientList.getSelectedValue();
                if (client != null) {
                    work(client);
                } else {
                    Client[] clients = ClientUtils.findAllClients(device);
                    if (clients.length > 0) {
                        ClientWrapper[] clientWrappers = new ClientWrapper[clients.length];
                        for (int i = 0; i < clientWrappers.length; i++) {
                            clientWrappers[i] = new ClientWrapper(clients[i]);
                        }
                        hideWaitDialog();

                        Object ret = JOptionPane.showInputDialog(Main.this,
                                "Choose a package to scan",
                                "Choose package",
                                JOptionPane.QUESTION_MESSAGE,
                                null,
                                clientWrappers,
                                clientWrappers[0]);
                        if (ret != null) {
                            work(((ClientWrapper) ret).client);
                        }
                    }
                }
            } finally {
                hideWaitDialog();
            }
        }

        private void work(Client c) {
            String pkg = c.getClientData().getClientDescription();
            showWaitDialog();
            updateWaitDialog("Retrieving heap data for " + pkg);

            try {
                Map<String, String> data = findAndGetHprof(pkg);
                addData(pkg, data);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        private class ClientWrapper {
            private Client client;

            public ClientWrapper(Client c) {
                client = c;
            }

            @Override
            public String toString() {
                return client.getClientData().getClientDescription() + " (pid "
                        + client.getClientData().getPid() + ")";
            }
        }
    }

    private class ScanAllPackagesAction extends AbstractAction implements Runnable {

        public ScanAllPackagesAction() {
            super("Scan all packages");
        }

        /*
         * (non-Javadoc)
         *
         * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
         */
        @Override
        public void actionPerformed(ActionEvent e) {
            new Thread(this).start();
        }

        /*
         * (non-Javadoc)
         *
         * @see java.lang.Runnable#run()
         */
        @Override
        public void run() {
            showWaitDialog();

            try {
                Client[] clients = ClientUtils.findAllClients(device);
                for (Client c : clients) {
                    String pkg = c.getClientData().getClientDescription();
                    showWaitDialog();
                    updateWaitDialog("Retrieving heap data for " + pkg);

                    try {
                        Map<String, String> data = getHprof(c);
                        addData(pkg, data);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            } finally {
                hideWaitDialog();
            }
        }
    }

    private class RunMonkeyAction extends AbstractAction {

        private final static String DEFAULT_MONKEY_PACKAGES =
                "com.android.calendar,com.android.gallery3d";

        public RunMonkeyAction() {
            super("Run monkey");
        }

        /*
         * (non-Javadoc)
         *
         * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
         */
        @Override
        public void actionPerformed(ActionEvent e) {
            String packages = JOptionPane.showInputDialog("Please enter packages name to run with"
                    + " the monkey, or leave empty for default.");
            if (packages == null) {
                return;
            }
            if (packages.isEmpty()) {
                packages = DEFAULT_MONKEY_PACKAGES;
            }
            new Thread(new RunMonkeyRunnable(packages)).start();
        }

        private class RunMonkeyRunnable implements Runnable {

            private String packages;
            private final static int ITERATIONS = 1000;

            public RunMonkeyRunnable(String packages) {
                this.packages = packages;
            }

            /*
             * (non-Javadoc)
             *
             * @see java.lang.Runnable#run()
             */
            @Override
            public void run() {
                showWaitDialog();

                try {
                    String pkgs[] = packages.split(",");

                    for (String pkg : pkgs) {
                        updateWaitDialog("Running monkey on " + pkg);

                        try {
                            // Stop running app.
                            forceStop(pkg);

                            // Little bit of breather here.
                            try {
                                Thread.sleep(1000);
                            } catch (Exception e) {
                            }

                            DeviceUtils.doShell(device, "monkey -p " + pkg + " " + ITERATIONS, 1,
                                    TimeUnit.MINUTES);

                            updateWaitDialog("Retrieving heap data for " + pkg);
                            Map<String, String> data = findAndGetHprof(pkg);
                            addData(pkg, data);
                        } catch (Exception e) {
                            e.printStackTrace();
                        } finally {
                            // Stop running app.
                            forceStop(pkg);
                        }
                    }
                } finally {
                    hideWaitDialog();
                }
            }
        }
    }

    private void forceStop(String packageName) {
        // Stop running app.
        DeviceUtils.doShell(device, "force-stop " + packageName, 5, TimeUnit.SECONDS);
        DeviceUtils.doShell(device, "kill " + packageName, 5, TimeUnit.SECONDS);
        DeviceUtils.doShell(device, "kill `pid " + packageName + "`", 5, TimeUnit.SECONDS);
    }

    private Map<String, String> findAndGetHprof(String packageName) throws Exception {
        Client client = ClientUtils.findClient(device, packageName, -1);
        if (client == null) {
            throw new RuntimeException("Could not find client...");
        }
        System.out.println("Found client: " + client);

        return getHprof(client);
    }

    private Map<String, String> getHprof(Client client) throws Exception {
        File hprofLocalFile = Hprof.doHprof(client, 120000);
        if (hprofLocalFile == null) {
            throw new RuntimeException("Failed getting dump...");
        }
        System.out.println("Dump file is " + hprofLocalFile);

        return Hprof.analyzeHprof(hprofLocalFile);
    }

    private class ShowDataAction extends AbstractAction {
        public ShowDataAction() {
            super("Show data");
        }

        /*
         * (non-Javadoc)
         *
         * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
         */
        @Override
        public void actionPerformed(ActionEvent e) {
            // TODO(agampe): Auto-generated method stub
            int selRow = dataTable.getSelectedRow();
            if (selRow != -1) {
                DumpData data = dataTableModel.getData().get(selRow);
                Map<String, Set<String>> inv = data.invertData();

                StringBuilder builder = new StringBuilder();

                // First bootclasspath.
                add(builder, "Boot classpath:", inv.get(null));

                // Now everything else.
                for (String k : inv.keySet()) {
                    if (k != null) {
                        builder.append("==================\n\n");
                        add(builder, k, inv.get(k));
                    }
                }

                JFrame newFrame = new JFrame(data.packageName + " " + data.date);
                newFrame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
                newFrame.getContentPane().add(new JScrollPane(new JTextArea(builder.toString())),
                        BorderLayout.CENTER);
                newFrame.setSize(800, 600);
                newFrame.setLocationRelativeTo(null);
                newFrame.setVisible(true);
            }
        }

        private void add(StringBuilder builder, String head, Set<String> set) {
            builder.append(head);
            builder.append('\n');
            addSet(builder, set);
            builder.append('\n');
        }

        private void addSet(StringBuilder builder, Set<String> set) {
            if (set == null) {
                builder.append("  NONE\n");
                return;
            }
            List<String> sorted = new ArrayList<>(set);
            Collections.sort(sorted);
            for (String s : sorted) {
                builder.append(s);
                builder.append('\n');
            }
        }
    }

    private class ComputeThresholdAction extends AbstractAction implements Runnable {
        protected int threshold;
        private Pattern blacklist;

        public ComputeThresholdAction(String name, int threshold, String blacklist) {
            super(name);
            this.threshold = threshold;
            if (blacklist != null) {
                this.blacklist = Pattern.compile(blacklist);
            }
        }

        /*
         * (non-Javadoc)
         *
         * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
         */
        @Override
        public void actionPerformed(ActionEvent e) {
            List<DumpData> data = dataTableModel.getData();
            if (data.size() == 0) {
                JOptionPane.showMessageDialog(Main.this,
                        "No data available, please scan packages or run monkeys.");
                return;
            }
            if (data.size() == 1) {
                JOptionPane.showMessageDialog(Main.this,
                        "Cannot compute list from only one data set, please scan packages or run monkeys.");
                return;
            }

            new Thread(this).start();
        }

        @Override
        public void run() {
            showWaitDialog();

            Map<String, Set<String>> uses = new HashMap<String, Set<String>>();
            for (DumpData d : dataTableModel.getData()) {
                updateWaitDialog("Merging " + d.packageName);
                updateClassUse(d.packageName, uses, getBootClassPathClasses(d.dumpData));
            }

            updateWaitDialog("Computing thresholded set");
            Set<String> result = fromThreshold(uses, blacklist, threshold);
            hideWaitDialog();

            int ret = JOptionPane.showConfirmDialog(Main.this, "Computed a set with "
                    + result.size() + " classes, would you like to save to" + " disk?", "Save?",
                    JOptionPane.YES_NO_OPTION);
            if (ret == JOptionPane.YES_OPTION) {
                JFileChooser jfc = new JFileChooser();
                int ret2 = jfc.showSaveDialog(Main.this);
                if (ret2 == JFileChooser.APPROVE_OPTION) {
                    File f = jfc.getSelectedFile();
                    saveSet(result, f);
                }
            }
        }

        private Set<String> fromThreshold(Map<String, Set<String>> classUses, Pattern blacklist,
                int threshold) {
            TreeSet<String> ret = new TreeSet<>(); // TreeSet so it's nicely ordered by name.

            PrintWriter tmp = null;
            try {
                tmp = new PrintWriter("/tmp/class.data");
            } catch (Exception e) {
            }
            for (Map.Entry<String, Set<String>> e : classUses.entrySet()) {
                if (e.getValue().size() >= threshold) {
                    if (blacklist == null || !blacklist.matcher(e.getKey()).matches()) {
                        ret.add(e.getKey());
                        tmp.println(e.getKey() + ": " + e.getValue());
                    }
                }
            }
            tmp.close();

            return ret;
        }

        /**
         * @param classUses
         */
        private void updateClassUse(String pkg, Map<String, Set<String>> classUses,
                Set<String> classes) {
            for (String className : classes) {
                Set<String> old = classUses.get(className);
                if (old == null) {
                    classUses.put(className, new HashSet<String>());
                }
                classUses.get(className).add(pkg);
            }
        }

        private Set<String> getBootClassPathClasses(Map<String, String> source) {
            Set<String> ret = new HashSet<>();
            for (Map.Entry<String, String> e : source.entrySet()) {
                if (e.getValue() == null) {
                    ret.add(e.getKey());
                }
            }
            return ret;
        }
    }

    private class ComputeThresholdXAction extends ComputeThresholdAction {

        /**
         * @param name
         * @param blacklist
         */
        public ComputeThresholdXAction(String name, String blacklist) {
            super(name, 1, blacklist);
        }

        @Override
        public void run() {
            String value = JOptionPane.showInputDialog("Threshold?");

            if (value != null) {
                try {
                    threshold = Integer.parseInt(value);
                    super.run();
                } catch (Exception exc) {
                }
            }
        }
    }

    private static class DumpTableModel extends AbstractTableModel {

        private List<DumpData> data = new ArrayList<DumpData>();

        public void addData(DumpData d) {
            data.add(d);
            fireTableRowsInserted(data.size() - 1, data.size() - 1);
        }

        public void clear() {
            int size = data.size();
            if (size > 0) {
                data.clear();
                fireTableRowsDeleted(0, size - 1);
            }
        }

        public List<DumpData> getData() {
            return data;
        }

        @Override
        public int getRowCount() {
            return data.size();
        }

        /*
         * (non-Javadoc)
         *
         * @see javax.swing.table.TableModel#getColumnCount()
         */
        @Override
        public int getColumnCount() {
            return 4;
        }

        @Override
        public String getColumnName(int column) {
            switch (column) {
                case 0:
                    return "Package";
                case 1:
                    return "Date";
                case 2:
                    return "# All Classes";
                case 3:
                    return "# Boot Classpath Classes";

                default:
                    throw new IndexOutOfBoundsException(String.valueOf(column));
            }
        }

        /*
         * (non-Javadoc)
         *
         * @see javax.swing.table.TableModel#getValueAt(int, int)
         */
        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            DumpData d = data.get(rowIndex);
            switch (columnIndex) {
                case 0:
                    return d.packageName;
                case 1:
                    return d.date;
                case 2:
                    return d.dumpData.size();
                case 3:
                    return d.bcpClasses;

                default:
                    throw new IndexOutOfBoundsException(String.valueOf(columnIndex));
            }
        }
    }

    /**
     * @param result
     * @param f
     */
    private static void saveSet(Set<String> result, File f) {
        try {
            PrintWriter out = new PrintWriter(f);
            for (String s : result) {
                out.println(s);
            }
            out.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private class ExportAction extends AbstractAction implements Runnable {
        private File lastSaveFile;

        public ExportAction() {
            super("Export data");
        }

        /*
         * (non-Javadoc)
         *
         * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
         */
        @Override
        public void actionPerformed(ActionEvent e) {
            if (jfc == null) {
                jfc = new JFileChooser();
            }
            jfc.setMultiSelectionEnabled(false);
            int ret = jfc.showSaveDialog(Main.this);
            if (ret == JFileChooser.APPROVE_OPTION) {
                lastSaveFile = jfc.getSelectedFile();
                new Thread(this).start();
            }
        }

        @Override
        public void run() {
            showWaitDialog();

            String serialized = DumpDataIO.serialize(dataTableModel.getData());

            if (serialized != null) {
                try {
                    PrintWriter out = new PrintWriter(lastSaveFile);
                    out.println(serialized);
                    out.close();

                    hideWaitDialog();
                } catch (Exception e) {
                    hideWaitDialog();
                    JOptionPane.showMessageDialog(Main.this, "Failed writing: " + e.getMessage());
                }
            }
        }
    }

    private class ImportAction extends AbstractAction implements Runnable {
        private File[] lastOpenFiles;

        public ImportAction() {
            super("Import data");
        }

        /*
         * (non-Javadoc)
         *
         * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
         */
        @Override
        public void actionPerformed(ActionEvent e) {
            if (jfc == null) {
                jfc = new JFileChooser();
            }
            jfc.setMultiSelectionEnabled(true);
            int ret = jfc.showOpenDialog(Main.this);
            if (ret == JFileChooser.APPROVE_OPTION) {
                lastOpenFiles = jfc.getSelectedFiles();
                new Thread(this).start();
            }
        }

        @Override
        public void run() {
            showWaitDialog();

            try {
                for (File f : lastOpenFiles) {
                    try {
                        Collection<DumpData> data = DumpDataIO.deserialize(f);

                        for (DumpData d : data) {
                            dataTableModel.addData(d);
                        }
                    } catch (Exception e) {
                        JOptionPane.showMessageDialog(Main.this,
                                "Failed reading: " + e.getMessage());
                    }
                }
            } finally {
                hideWaitDialog();
            }

        }
    }

}
