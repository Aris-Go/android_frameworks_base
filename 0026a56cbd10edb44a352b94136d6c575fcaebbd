{
  "comments": [
    {
      "key": {
        "uuid": "185a199e_d256e73a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1221725
      },
      "writtenOn": "2020-07-14T16:39:17Z",
      "side": 1,
      "message": "Took a gander through the code. I\u0027ll be happy when we can delete the LegacyVpnRunner altogether.",
      "revId": "0026a56cbd10edb44a352b94136d6c575fcaebbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ce7d12e7_18cf4123",
        "filename": "services/core/java/com/android/server/connectivity/Vpn.java",
        "patchSetId": 1
      },
      "lineNbr": 2772,
      "author": {
        "id": 1221725
      },
      "writtenOn": "2020-07-14T16:39:17Z",
      "side": 1,
      "message": "Not from this CL, but oof. I didn\u0027t realize we had these outside the synchronized block. Since other VPN runner types don\u0027t wait for pppd and racoon to teardown, this theoretically can be modifying state that was set by a new VPN.",
      "range": {
        "startLine": 2772,
        "startChar": 0,
        "endLine": 2772,
        "endChar": 57
      },
      "revId": "0026a56cbd10edb44a352b94136d6c575fcaebbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8dfe4a72_cb4d7bb9",
        "filename": "services/core/java/com/android/server/connectivity/Vpn.java",
        "patchSetId": 1
      },
      "lineNbr": 2800,
      "author": {
        "id": 1221725
      },
      "writtenOn": "2020-07-14T16:39:17Z",
      "side": 1,
      "message": "Reading through the code, I think there is a possibility for this to block the CS thread. I think the sinister part here is that InetAddress.getByName() cannot be interrupted, and thus any new call to startLegacyVpn() can block. This may, in turn lead to the ConnectivityService thread being blocked via the following call trace:\n* CS.updateNetworkInfo() -\u003e\n* CS.notifyLockdownVpn() -\u003e\n* mLockdownTracker.onNetworkInfoChanged() -\u003e\n* LockdownVpnTracker.handleStateChangedLocked() (also holds an additional lock) -\u003e\n* mVpn.startLegacyVpnPrivileged()\n\nMy only thought with regards to making this safe (without moving this out of the synchronized(TAG) block, which would allow multiple LegacyVpnRunners to be active at the same time) would be to:\n\n- At the start of bringup, trigger an async DnsResolver query, storing result into an AtomicReference or similar\n- Wait here until it is done using checkInterruptAndDelay(); effectively polling\n\nThis ensures we never go into an uninterruptible state on this LegacyVpnRunner thread",
      "range": {
        "startLine": 2800,
        "startChar": 49,
        "endLine": 2800,
        "endChar": 64
      },
      "revId": "0026a56cbd10edb44a352b94136d6c575fcaebbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e728b597_ad55bce5",
        "filename": "services/core/java/com/android/server/connectivity/Vpn.java",
        "patchSetId": 1
      },
      "lineNbr": 2800,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2020-07-16T10:47:13Z",
      "side": 1,
      "message": "This thread is already blocked for up to 60 seconds in the loop above:\n\n                // Wait for the daemons to create the new state.\n                while (!state.exists()) {\n                    // Check if a running daemon is dead.\n                    for (int i \u003d 0; i \u003c mDaemons.length; ++i) {\n                        String daemon \u003d mDaemons[i];\n                        if (mArguments[i] !\u003d null \u0026\u0026 !SystemService.isRunning(daemon)) {\n                            throw new IllegalStateException(daemon + \" is dead\");\n                        }\n                    }\n                    checkInterruptAndDelay(true);\n                }\n\nThat said - it seems better to do the DNS lookup before starting the daemon, because otherwise it could (unlikely) happen that the daemon starts but the DNS lookup fails and the throw route isn\u0027t created. There are a few ways I can see to do this:\n\n1. Do the DNS lookup before constructing the arguments (in startLegacyVpnPrivileged), and when constructing the arguments, use the IP address instead of profile.server. I don\u0027t know if it\u0027s safe to block there. I don\u0027t think it is.\n\n2. Do the DNS lookup before starting the daemon (in bringup, around line 2689), and rely on the DNS cache to return the same IP address that racoon got. This will not work if the DNS TTL is too low though. In this case the lookup could fail (which means we\u0027d have to fail the connection attempt) or, worse, we\u0027d create a throw route to the wrong IP address and bring up a VPN that doesn\u0027t work.\n\n3. Remember at which index in mArguments the server address is, and pass that down to this function. Then in this function do the DNS lookup and overwrite that index. Horrible, but would probably work.",
      "parentUuid": "8dfe4a72_cb4d7bb9",
      "range": {
        "startLine": 2800,
        "startChar": 49,
        "endLine": 2800,
        "endChar": 64
      },
      "revId": "0026a56cbd10edb44a352b94136d6c575fcaebbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a2338a3_8c89d6ad",
        "filename": "tests/net/java/com/android/server/connectivity/VpnTest.java",
        "patchSetId": 1
      },
      "lineNbr": 1045,
      "author": {
        "id": 1221725
      },
      "writtenOn": "2020-07-14T16:39:17Z",
      "side": 1,
      "message": "Not sure if this will work if the device has no connectivity, or google.com isn\u0027t resolvable (eg AOSP devs in China). Would localhost here work? It\u0027d also have the added benefit of instantly resolving.",
      "range": {
        "startLine": 1045,
        "startChar": 25,
        "endLine": 1045,
        "endChar": 41
      },
      "revId": "0026a56cbd10edb44a352b94136d6c575fcaebbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51390832_5192e33c",
        "filename": "tests/net/java/com/android/server/connectivity/VpnTest.java",
        "patchSetId": 1
      },
      "lineNbr": 1047,
      "author": {
        "id": 1015428
      },
      "writtenOn": "2020-07-14T15:13:34Z",
      "side": 1,
      "message": "Right now this doesn\u0027t pass â€“ this needs to wait for the legacy VPN runner thread to be done.",
      "range": {
        "startLine": 1047,
        "startChar": 8,
        "endLine": 1047,
        "endChar": 21
      },
      "revId": "0026a56cbd10edb44a352b94136d6c575fcaebbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}