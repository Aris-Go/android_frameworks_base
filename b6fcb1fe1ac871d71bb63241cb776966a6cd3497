{
  "comments": [
    {
      "key": {
        "uuid": "42264aac_18e9f6d1",
        "filename": "services/core/java/com/android/server/connectivity/NetworkMonitor.java",
        "patchSetId": 2
      },
      "lineNbr": 234,
      "author": {
        "id": 1000451
      },
      "writtenOn": "2017-06-29T13:03:43Z",
      "side": 1,
      "message": "Should be possible for this to be type Network too, I would expect.",
      "range": {
        "startLine": 234,
        "startChar": 18,
        "endLine": 234,
        "endChar": 44
      },
      "revId": "b6fcb1fe1ac871d71bb63241cb776966a6cd3497",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5998689a_b6c4a24f",
        "filename": "services/core/java/com/android/server/connectivity/NetworkMonitor.java",
        "patchSetId": 2
      },
      "lineNbr": 234,
      "author": {
        "id": 1107893
      },
      "writtenOn": "2017-06-29T13:39:16Z",
      "side": 1,
      "message": "Yes please keep this as Network.",
      "parentUuid": "42264aac_18e9f6d1",
      "range": {
        "startLine": 234,
        "startChar": 18,
        "endLine": 234,
        "endChar": 44
      },
      "revId": "b6fcb1fe1ac871d71bb63241cb776966a6cd3497",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb0f6bd9_1241d89d",
        "filename": "services/core/java/com/android/server/connectivity/NetworkMonitor.java",
        "patchSetId": 2
      },
      "lineNbr": 708,
      "author": {
        "id": 1107893
      },
      "writtenOn": "2017-06-29T13:52:35Z",
      "side": 1,
      "message": "This is unnecessary regression from patch set #1 in term of complexity.\n\nThis is much easier if your shuffle first and then group by in the map. Also please don\u0027t reimplement shuffle, use Collections.shuffle instead.\n\nYou don\u0027t even need to care about overwriting anymore. Just do:\n\nList\u003c...\u003e addrs \u003d Arrays.asList(getAllByName)\nCollection.shuffle(addrs);\nfor (InetAddress addr : addrs) {\n  map.put(addr.getClass(), addr); // last write wins\n}\nreturn map.values.toArray(new InetAddress[]);\n\n\nShuffle + group by is technically 2 iterations whereas here you have only one, but much more allocations + fetching in subarrays. Since this is getAllByName returns a small array the second iteration is free because caching.",
      "range": {
        "startLine": 694,
        "startChar": 12,
        "endLine": 708,
        "endChar": 13
      },
      "revId": "b6fcb1fe1ac871d71bb63241cb776966a6cd3497",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5ea61930_aaed392d",
        "filename": "services/core/java/com/android/server/connectivity/NetworkMonitor.java",
        "patchSetId": 2
      },
      "lineNbr": 708,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2017-06-29T14:23:34Z",
      "side": 1,
      "message": "We can\u0027t shuffle first because we want to preserve the order of address families. For example, if getaddrinfo() returns one IPv6 address followed by 5 IPv4 address, we must return the IPv6 address first, followed by one of the IPv4 addresses.\n\nThe code could probably be made faster and simpler by making it less generic, along the lines of:\n\n    InetAddress[] addrs \u003d super.getAllByName(host);\n    boolean v6first \u003d addrs[0] instanceof Inet6Address;\n    InetAddress[] out \u003d new InetAddress[2];\n\n    Collections.shuffle(addrs);\n    for (InetAddress addr : addrs) {\n        if ((v6first \u0026\u0026 addr instanceof Inet6Address) ||\n            (!v6first \u0026\u0026 addr instanceof Inet4Address)) {\n            out[0] \u003d addr;\n            break;\n        }\n    }\n    for (InetAddress addr : addrs) {\n        if ((v6first \u0026\u0026 addr instanceof Inet4Address) ||\n            (!v6first \u0026\u0026 addr instanceof Inet6Address)) {\n            out[1] \u003d addr;\n            break;\n        }\n    }\n    return out;\n\nI\u0027m not sure if that\u0027s any better than what\u0027s in this patchset. I don\u0027t feel strongly about any of these options, as long as they get the order right.",
      "parentUuid": "eb0f6bd9_1241d89d",
      "range": {
        "startLine": 694,
        "startChar": 12,
        "endLine": 708,
        "endChar": 13
      },
      "revId": "b6fcb1fe1ac871d71bb63241cb776966a6cd3497",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5ef0940e_21188186",
        "filename": "services/core/java/com/android/server/connectivity/NetworkMonitor.java",
        "patchSetId": 2
      },
      "lineNbr": 708,
      "author": {
        "id": 1107893
      },
      "writtenOn": "2017-06-29T14:45:36Z",
      "side": 1,
      "message": "If the order of IP family absolutely needs to be preserved that is still easy to add without much more complexity. Simply do before the shuffle: map.put(addrs[0].getClass(), addrs[0]); and this will force the first IP family, with a guard against empty array for good measure.\n\n(alternatively if we had a generic ReservoirSampling\u003cT\u003e family you could replace the ArrayList with it to do the random sampling in the group-by-family, and family ordering properties would still be preserved, but that\u0027s not available)\n\nThe solution looking for both family separately does not work when addrs of only one family are present.",
      "parentUuid": "5ea61930_aaed392d",
      "range": {
        "startLine": 694,
        "startChar": 12,
        "endLine": 708,
        "endChar": 13
      },
      "revId": "b6fcb1fe1ac871d71bb63241cb776966a6cd3497",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc0bd732_99d8bbbf",
        "filename": "services/core/java/com/android/server/connectivity/NetworkMonitor.java",
        "patchSetId": 2
      },
      "lineNbr": 708,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2017-06-29T15:14:25Z",
      "side": 1,
      "message": "Putting the first address in the map only preserves the ordering if it is guaranteed that there are only two types of addresses. Since that\u0027s the case here (at least for a few more decades), done.",
      "parentUuid": "5ef0940e_21188186",
      "range": {
        "startLine": 694,
        "startChar": 12,
        "endLine": 708,
        "endChar": 13
      },
      "revId": "b6fcb1fe1ac871d71bb63241cb776966a6cd3497",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}