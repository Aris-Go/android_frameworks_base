{
  "comments": [
    {
      "key": {
        "uuid": "cd443869_975ab64d",
        "filename": "graphics/java/android/graphics/drawable/VectorDrawable.java",
        "patchSetId": 1
      },
      "lineNbr": 336,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-20T19:11:24Z",
      "side": 1,
      "message": "I don\u0027t fully understand the context here, but purely from a concurrency perspective, this looks wrong.\n\nhttps://developer.android.com/guide/components/processes-and-threads.html says clearly:\n\n2. Do not access the Android UI toolkit from outside the UI thread\n\nSo why are we calling VectorDrawable.draw() from multiple threads, in violation of this condition? Given that nDraw() is presumably not thread-safe because it bottoms out in thread-unsafe Skia calls, how do we know it\u0027s safe to call it concurrently with other Skia code?\n\nIt seems really odd to acquire a lock in only a single method; we really need a clear statement about what data is protected by the VectorDrawable.class lock, and then protect those accesses consistently.\n\nIf you really believe that this is correct, please comment clearly what the concurrent access rules are here.",
      "range": {
        "startLine": 336,
        "startChar": 8,
        "endLine": 336,
        "endChar": 44
      },
      "revId": "cb23352bf1d0cab38303535f67750003feb9d177",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dde44f20_9b6c0bfd",
        "filename": "graphics/java/android/graphics/drawable/VectorDrawable.java",
        "patchSetId": 1
      },
      "lineNbr": 336,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2018-03-20T19:23:23Z",
      "side": 1,
      "message": "I believe it is the ref \u0026 unref of the colorFilter specifically that this is trying to guard against, and the result of the incorrect threading usage is the ref/unref race condition.\n\nThinking about this more though it\u0027s going to mean that independent objects owned by independent threads will no longer be able to draw concurrently. That is allowable per the threading rules, but this will bottleneck them on the class synchronization.",
      "parentUuid": "cd443869_975ab64d",
      "range": {
        "startLine": 336,
        "startChar": 8,
        "endLine": 336,
        "endChar": 44
      },
      "revId": "cb23352bf1d0cab38303535f67750003feb9d177",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b75c39cc_4158a264",
        "filename": "graphics/java/android/graphics/drawable/VectorDrawable.java",
        "patchSetId": 1
      },
      "lineNbr": 336,
      "author": {
        "id": 1053203
      },
      "writtenOn": "2018-03-20T20:36:40Z",
      "side": 1,
      "message": "Why are there draw() calls on the same VectorDrawable instance from multiple threads in the first place? nDraw in native assumes the VectorDrawable.draw() to always be on the UI thread, and accesses the UI thread owned staging properties. Allowing another thread to modify these problems is potentially unsafe.",
      "parentUuid": "dde44f20_9b6c0bfd",
      "range": {
        "startLine": 336,
        "startChar": 8,
        "endLine": 336,
        "endChar": 44
      },
      "revId": "cb23352bf1d0cab38303535f67750003feb9d177",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e8e72629_354bb56f",
        "filename": "graphics/java/android/graphics/drawable/VectorDrawable.java",
        "patchSetId": 1
      },
      "lineNbr": 336,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-20T21:01:30Z",
      "side": 1,
      "message": "So the intent is that a VectorDrawable is what most parts of Google call \"thread-compatible\", i.e. it\u0027s the caller\u0027s job to ensure that there are no concurrent calls such that one of them modifies the object? That\u0027s appreciably different from the documentation I quoted above, which allows it to be \"thread-hostile\" in Google terminology, i.e. only callable from one thread because e.g. it accesses static data without protection.\n\nI couldn\u0027t find enough of a stack trace or the like to understand the original problem. And it seems hard to track down all the relevant code here.\n\nIt should be OK to call ref and unref from different threads, assuming the destructor doesn\u0027t care where it\u0027s called from. I think that was always required, since both the finalizer and NativeAllocationRegistry Cleaner run in a different threads. But if they\u0027re getting data race warnings, then we presumably have racing assignments to the same reference-counted pointer, and those are very bad.\n\nBased on the code I did find, there seemed to be a surprising(?) type change to the SkSafeUnref argument in ag/2461918/1/core/jni/android/graphics/ColorFilter.cpp. Is that OK/intended?",
      "parentUuid": "dde44f20_9b6c0bfd",
      "range": {
        "startLine": 336,
        "startChar": 8,
        "endLine": 336,
        "endChar": 44
      },
      "revId": "cb23352bf1d0cab38303535f67750003feb9d177",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}