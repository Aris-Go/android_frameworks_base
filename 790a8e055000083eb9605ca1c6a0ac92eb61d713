{
  "comments": [
    {
      "key": {
        "uuid": "7a2e542d_e25893c1",
        "filename": "core/java/android/net/ConnectivityManager.java",
        "patchSetId": 1
      },
      "lineNbr": 3481,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2019-04-29T12:16:19Z",
      "side": 1,
      "message": "Is it safe to take the sCallbacks lock, release it, and take it again here? Are no guarantees of atomicity necessary between the sCallbacks.get() call above and this remove()?\n\nFor example, what happens if the app calls unregisterNetworkCallback between line 3452 and here?\n\nIf this would cause a problem, then maybe you could move this code into the synchronized block in line 3452. Might be worth doing that anyway, actually.",
      "range": {
        "startLine": 3481,
        "startChar": 20,
        "endLine": 3481,
        "endChar": 47
      },
      "revId": "790a8e055000083eb9605ca1c6a0ac92eb61d713",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "04daeb71_e633cece",
        "filename": "core/java/android/net/ConnectivityManager.java",
        "patchSetId": 1
      },
      "lineNbr": 3481,
      "author": {
        "id": 1039103
      },
      "writtenOn": "2019-04-29T14:33:01Z",
      "side": 1,
      "message": "Seems safe as-is:\n- If removed then another remove has no further impact\n- The state modification to ALREADY_UNREGISTERED would be a race, but are synchronized\n\nMoving the code further up would be architecturally problematic. Line 3452 is generic, then the switch is specific behavior. I\u0027d rather keep the two separate.",
      "parentUuid": "7a2e542d_e25893c1",
      "range": {
        "startLine": 3481,
        "startChar": 20,
        "endLine": 3481,
        "endChar": 47
      },
      "revId": "790a8e055000083eb9605ca1c6a0ac92eb61d713",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dce58baa_05c896e6",
        "filename": "core/java/android/net/ConnectivityManager.java",
        "patchSetId": 1
      },
      "lineNbr": 3481,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2019-05-01T01:30:23Z",
      "side": 1,
      "message": "Hmm. This still bothers me, but I can\u0027t come up with a solid argument against it.\n\nGenerally, accessing the same data structure twice in the same operation under two different locks is incorrect because state may have changed in the meantime. But I think in this case the code is correct. So the best I can come up with is that putting another synchronized block lock here requires more thought in code review and in future refactoring to maintain correctness.\n\nFor example, if someone copy+pastes this other synchronized block, and then does something in it that *does* require atomicity with the get above, they\u0027ll will have added a bug. If all the code that touches sCallbacks in this function is in the same lock, then there will be no such misleading code to copy+paste.\n\nPhilosophically, I don\u0027t think it\u0027s true that it\u0027s an architectural issue to move the code; I think architecture is more about class structure, threading, and locking than it is about separating code blocks. But you\u0027re right that separating the code blocks would make things a bit more brittle.\n\nMaybe leave the code as is and add a comment here explaining that this extra synchronized block is safe because removes are idempotent and the remove doesn\u0027t do anything if the callback has already been removed?",
      "parentUuid": "04daeb71_e633cece",
      "range": {
        "startLine": 3481,
        "startChar": 20,
        "endLine": 3481,
        "endChar": 47
      },
      "revId": "790a8e055000083eb9605ca1c6a0ac92eb61d713",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96ac1a97_cbd3c973",
        "filename": "core/java/android/net/ConnectivityManager.java",
        "patchSetId": 1
      },
      "lineNbr": 3481,
      "author": {
        "id": 1039103
      },
      "writtenOn": "2019-05-01T13:56:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dce58baa_05c896e6",
      "range": {
        "startLine": 3481,
        "startChar": 20,
        "endLine": 3481,
        "endChar": 47
      },
      "revId": "790a8e055000083eb9605ca1c6a0ac92eb61d713",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d2523fb7_0c6f4782",
        "filename": "core/java/android/net/ConnectivityManager.java",
        "patchSetId": 1
      },
      "lineNbr": 3481,
      "author": {
        "id": 1015428
      },
      "writtenOn": "2019-05-07T06:41:52Z",
      "side": 1,
      "message": "Wait. Reading this makes me realize there IS a case where that\u0027s bad.\nWe allow reusing a callback after it\u0027s been unregistered ( https://cs.corp.google.com/android/frameworks/base/core/java/android/net/ConnectivityManager.java?q\u003dconnectivitymanager.java\u0026dr\u0026l\u003d3538 ). So if between the get() and this, the app unregisters and registers again with the same callback, this will wrongly remove it.",
      "parentUuid": "96ac1a97_cbd3c973",
      "range": {
        "startLine": 3481,
        "startChar": 20,
        "endLine": 3481,
        "endChar": 47
      },
      "revId": "790a8e055000083eb9605ca1c6a0ac92eb61d713",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5d1ddad6_bb333758",
        "filename": "core/java/android/net/ConnectivityManager.java",
        "patchSetId": 1
      },
      "lineNbr": 3481,
      "author": {
        "id": 1039103
      },
      "writtenOn": "2019-05-07T21:15:17Z",
      "side": 1,
      "message": "OK - moving the code up to the single synchronization block (per Lorenzo\u0027s original suggestion).\n\nHowever: there is still a race condition possible due to this re-use.\n- App unregisters and re-registers the callback\n- All the while the service is executing an onUnavailable\n\nThe issue is with the architecture - ideally there shouldn\u0027t be an app-side registry (which duplicates information on the service side). The only list should be maintained by the service.",
      "parentUuid": "d2523fb7_0c6f4782",
      "range": {
        "startLine": 3481,
        "startChar": 20,
        "endLine": 3481,
        "endChar": 47
      },
      "revId": "790a8e055000083eb9605ca1c6a0ac92eb61d713",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "16b9fce2_b0edf377",
        "filename": "core/java/android/net/ConnectivityManager.java",
        "patchSetId": 1
      },
      "lineNbr": 3481,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2019-05-08T13:45:45Z",
      "side": 1,
      "message": "Actually, I think it\u0027s the other way around: it can\u0027t be done on the service side, because there is no synchronous access to service-side data. (The service is just an event loop.) The only place where synchronous calls can have immediate effect is client-side data.\n\nAs for the race, are you saying the problem scenario is the following?\n\n1. App calls unregisterNetworkCallback. Unregister request is queued on CS handler. Unregister completes.\n2. Unavailable timer fires. CALLBACK_UNAVAIL message is sent to app messenger.\n3. App calls requestNetwork with same callback object.\n4. Message from #3 arrives and app gets onUnavailable callback, even though the request timeout has not yet fired.\n\nCan 3 actually happen, though? requestNetwork will allocate a new request ID, so the onUnavailable will be ignored.",
      "parentUuid": "5d1ddad6_bb333758",
      "range": {
        "startLine": 3481,
        "startChar": 20,
        "endLine": 3481,
        "endChar": 47
      },
      "revId": "790a8e055000083eb9605ca1c6a0ac92eb61d713",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}